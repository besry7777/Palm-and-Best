<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‡∏´‡∏°‡∏≤‡∏Å‡∏Æ‡∏≠‡∏™ 8x8</title>
    <style>
        :root {
            --board-bg-dark: #b58863;
            --board-bg-light: #f0d9b5;
            --piece-red: #c41e3a;
            --piece-blue: #007bff;
            --piece-shadow: rgba(0,0,0,0.4);
            --selected-glow: #32cd32;
            --valid-move-dot: rgba(0, 0, 0, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #333;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 95%;
            max-width: 500px;
        }

        .game-header {
            width: 100%;
            text-align: center;
        }

        .game-header h1 {
            font-size: 2.5em;
            text-shadow: 2px 2px 4px #000;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            background-color: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
        }
        
        .player-info {
            font-weight: bold;
            font-size: 1.1em;
            padding: 8px 12px;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .player-info.red {
            background-color: var(--piece-red);
        }
        
        .player-info.blue {
            background-color: var(--piece-blue);
        }

        .player-info.active {
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--selected-glow);
        }

        #turn-status {
            font-size: 1.2em;
            font-weight: bold;
        }

        .game-board {
            width: 100%;
            aspect-ratio: 1/1;
            background-color: #ccc;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            position: relative;
        }

        .square {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .square.dark {
            background-color: var(--board-bg-dark);
        }

        .square.light {
            background-color: var(--board-bg-light);
        }

        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: inset 0 -4px 6px var(--piece-shadow), 0 2px 2px rgba(255,255,255,0.5);
            transition: all 0.2s ease-in-out;
            position: relative; /* For king icon */
        }
        
        .piece.red { background-color: var(--piece-red); }
        .piece.blue { background-color: var(--piece-blue); }

        .piece.selected {
            transform: scale(1.1);
            box-shadow: 0 0 10px 3px var(--selected-glow);
        }

        .piece.king::after {
            content: 'üëë';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: calc(min(3vw, 20px));
            text-shadow: 0px 0px 2px #000;
        }
        
        .valid-move-indicator {
            width: 30%;
            height: 30%;
            background-color: var(--valid-move-dot);
            border-radius: 50%;
            pointer-events: none; /* Allows clicks to pass through to the square */
        }

        .controls {
            margin-top: 10px;
        }

        #restartBtn {
            padding: 12px 25px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            background-color: #2ecc71;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        #restartBtn:hover {
            background-color: #27ae60;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="game-header">
            <h1>‡∏´‡∏°‡∏≤‡∏Å‡∏Æ‡∏≠‡∏™</h1>
        </div>

        <div class="status-bar">
            <div id="player1Info" class="player-info red">‡πÅ‡∏î‡∏á: 12</div>
            <div id="player2Info" class="player-info blue">‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô: 12</div>
        </div>

        <div class="game-board" id="gameBoard"></div>

        <div class="controls">
            <button id="restartBtn">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà</button>
        </div>
    </div>

    <script>
        const gameBoard = document.getElementById('gameBoard');
        const restartBtn = document.getElementById('restartBtn');
        const player1Info = document.getElementById('player1Info');
        const player2Info = document.getElementById('player2Info');

        const BOARD_SIZE = 8;
        const P1 = 1; // Red
        const P2 = 2; // Blue
        const P1_KING = 3;
        const P2_KING = 4;

        let boardState = [];
        let currentPlayer = P1;
        let selectedPiece = null; // { row, col, element }
        let mustCapture = false;
        let turnInProgress = false;

        function createBoard() {
            boardState = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if ((row + col) % 2 !== 0) {
                        boardState[row][col] = P2; // Player 2 (Blue) on top
                    }
                }
            }

            for (let row = BOARD_SIZE - 3; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if ((row + col) % 2 !== 0) {
                        boardState[row][col] = P1; // Player 1 (Red) on bottom
                    }
                }
            }
        }

        function renderBoard() {
            gameBoard.innerHTML = '';
            let p1Count = 0;
            let p2Count = 0;
            
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.classList.add((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;

                    const pieceType = boardState[row][col];
                    if (pieceType !== 0) {
                        const piece = document.createElement('div');
                        piece.classList.add('piece');
                        if (pieceType === P1 || pieceType === P1_KING) {
                            piece.classList.add('red');
                            p1Count++;
                        } else {
                            piece.classList.add('blue');
                            p2Count++;
                        }
                        if (pieceType === P1_KING || pieceType === P2_KING) {
                            piece.classList.add('king');
                        }
                        square.appendChild(piece);
                    }
                    gameBoard.appendChild(square);
                }
            }
            updateStatus(p1Count, p2Count);
        }
        
        function updateStatus(p1Count, p2Count) {
            player1Info.textContent = `‡πÅ‡∏î‡∏á: ${p1Count}`;
            player2Info.textContent = `‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô: ${p2Count}`;
            
            player1Info.classList.remove('active');
            player2Info.classList.remove('active');
            
            if(currentPlayer === P1) {
                player1Info.classList.add('active');
            } else {
                player2Info.classList.add('active');
            }
        }

        function getValidMoves(row, col, pieceType) {
            let moves = [];
            const isKing = (pieceType === P1_KING || pieceType === P2_KING);
            const player = (pieceType === P1 || pieceType === P1_KING) ? P1 : P2;
            const opponent = (player === P1) ? [P2, P2_KING] : [P1, P1_KING];
            const directions = isKing ? [[-1,-1], [-1,1], [1,-1], [1,1]] : (player === P1 ? [[-1,-1], [-1,1]] : [[1,-1], [1,1]]);

            // Check for captures first
            for(const [dr, dc] of directions) {
                if(isKing) {
                     for(let i = 1; i < BOARD_SIZE; i++) {
                        const newRow = row + dr * i;
                        const newCol = col + dc * i;
                        const nextRow = newRow + dr;
                        const nextCol = newCol + dc;

                        if(!isValid(newRow, newCol) || !isValid(nextRow, nextCol)) break;

                        if (opponent.includes(boardState[newRow][newCol]) && boardState[nextRow][nextCol] === 0) {
                            moves.push({ to: [nextRow, nextCol], capture: [newRow, newCol] });
                            // King can't jump over multiple empty squares to capture
                            break; 
                        }
                        if (boardState[newRow][newCol] !== 0) break;
                    }
                } else {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    const nextRow = row + dr * 2;
                    const nextCol = col + dc * 2;
                    if(isValid(nextRow, nextCol) && opponent.includes(boardState[newRow][newCol]) && boardState[nextRow][nextCol] === 0) {
                        moves.push({ to: [nextRow, nextCol], capture: [newRow, newCol] });
                    }
                }
            }
            
            // If captures are possible, only they are valid
            if (moves.length > 0) {
                mustCapture = true;
                return moves;
            }

            // If no captures, check for regular moves
            if (mustCapture) return []; // If a capture is mandatory somewhere else, this piece can't do a simple move.

            for(const [dr, dc] of directions) {
                if(isKing) {
                    for(let i = 1; i < BOARD_SIZE; i++) {
                        const newRow = row + dr * i;
                        const newCol = col + dc * i;
                        if(!isValid(newRow, newCol) || boardState[newRow][newCol] !== 0) break;
                        moves.push({ to: [newRow, newCol] });
                    }
                } else {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if(isValid(newRow, newCol) && boardState[newRow][newCol] === 0) {
                        moves.push({ to: [newRow, newCol] });
                    }
                }
            }
            return moves;
        }

        function checkForMandatoryCaptures(player) {
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const piece = boardState[r][c];
                    if (piece !== 0 && (player === P1 ? (piece === P1 || piece === P1_KING) : (piece === P2 || piece === P2_KING))) {
                        if (getValidMoves(r, c, piece).some(move => move.capture)) {
                           return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function handleSquareClick(e) {
            if (turnInProgress) return;
            const target = e.target.closest('.square');
            if (!target) return;

            const row = parseInt(target.dataset.row);
            const col = parseInt(target.dataset.col);
            const pieceType = boardState[row][col];
            const clickedPiece = target.querySelector('.piece');
            const isCurrentPlayerPiece = (currentPlayer === P1 && (pieceType === P1 || pieceType === P1_KING)) ||
                                         (currentPlayer === P2 && (pieceType === P2 || pieceType === P2_KING));

            if (selectedPiece) {
                // Attempting to move
                const validMoves = getValidMoves(selectedPiece.row, selectedPiece.col, boardState[selectedPiece.row][selectedPiece.col]);
                const move = validMoves.find(m => m.to[0] === row && m.to[1] === col);
                
                if (move) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col, move.capture);
                } else {
                    // Clicked somewhere else, deselect
                    clearHighlights();
                    selectedPiece = null;
                }
            } else if (isCurrentPlayerPiece) {
                // Selecting a piece
                clearHighlights();
                mustCapture = checkForMandatoryCaptures(currentPlayer);
                const validMoves = getValidMoves(row, col, pieceType);
                if(mustCapture && !validMoves.some(m => m.capture)) {
                    // This piece cannot move because another piece must capture
                    return;
                }
                if(validMoves.length > 0) {
                    selectedPiece = { row, col, element: clickedPiece };
                    clickedPiece.classList.add('selected');
                    highlightValidMoves(validMoves);
                }
            }
        }
        
        async function movePiece(fromRow, fromCol, toRow, toCol, captured) {
            turnInProgress = true;
            const pieceType = boardState[fromRow][fromCol];
            boardState[toRow][toCol] = pieceType;
            boardState[fromRow][fromCol] = 0;
            
            if (captured) {
                boardState[captured[0]][captured[1]] = 0;
            }
            
            // Check for King promotion
            if (pieceType === P1 && toRow === 0) boardState[toRow][toCol] = P1_KING;
            if (pieceType === P2 && toRow === BOARD_SIZE - 1) boardState[toRow][toCol] = P2_KING;
            
            selectedPiece = null;
            clearHighlights();
            renderBoard();
            await new Promise(res => setTimeout(res, 100)); // Short delay for rendering

            // Check for multi-jump
            if (captured) {
                const multiJumpMoves = getValidMoves(toRow, toCol, boardState[toRow][toCol]).filter(m => m.capture);
                if (multiJumpMoves.length > 0) {
                    selectedPiece = { row: toRow, col: toCol, element: gameBoard.children[toRow * BOARD_SIZE + toCol].querySelector('.piece') };
                    selectedPiece.element.classList.add('selected');
                    highlightValidMoves(multiJumpMoves);
                    turnInProgress = false; // Allow next jump
                    return;
                }
            }
            
            switchTurn();
            turnInProgress = false;
        }

        function switchTurn() {
            currentPlayer = (currentPlayer === P1) ? P2 : P1;
            checkWinCondition();
        }

        function checkWinCondition() {
            let p1Pieces = 0;
            let p2Pieces = 0;
            let p1Moves = 0;
            let p2Moves = 0;
            
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    const piece = boardState[r][c];
                    if(piece === P1 || piece === P1_KING) {
                        p1Pieces++;
                        if(currentPlayer === P1) p1Moves += getValidMoves(r, c, piece).length;
                    } else if (piece === P2 || piece === P2_KING) {
                        p2Pieces++;
                        if(currentPlayer === P2) p2Moves += getValidMoves(r, c, piece).length;
                    }
                }
            }
            
            updateStatus(p1Pieces, p2Pieces);

            if(p1Pieces === 0) announceWinner(P2);
            else if (p2Pieces === 0) announceWinner(P1);
            else if (currentPlayer === P1 && p1Moves === 0) announceWinner(P2);
            else if (currentPlayer === P2 && p2Moves === 0) announceWinner(P1);
        }

        function announceWinner(player) {
            turnInProgress = true;
            const winnerName = player === P1 ? "‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏™‡∏µ‡πÅ‡∏î‡∏á" : "‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô";
            setTimeout(() => {
                alert(`${winnerName} ‡πÄ‡∏õ‡πá‡∏ô‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞!`);
            }, 300);
        }

        function isValid(row, col) {
            return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
        }

        function highlightValidMoves(moves) {
            moves.forEach(move => {
                const square = gameBoard.children[move.to[0] * BOARD_SIZE + move.to[1]];
                const indicator = document.createElement('div');
                indicator.className = 'valid-move-indicator';
                square.appendChild(indicator);
            });
        }
        
        function clearHighlights() {
            document.querySelectorAll('.piece.selected').forEach(p => p.classList.remove('selected'));
            document.querySelectorAll('.valid-move-indicator').forEach(i => i.remove());
        }

        function initGame() {
            createBoard();
            renderBoard();
            currentPlayer = P1;
            selectedPiece = null;
            mustCapture = false;
            turnInProgress = false;
            gameBoard.addEventListener('click', handleSquareClick);
        }
        
        restartBtn.addEventListener('click', initGame);
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
