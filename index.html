<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>หมากฮอตมาตรฐานสากล</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Noto Sans Thai', sans-serif;
        }
        
        body {
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        h1 {
            color: #2c3e50;
            margin: 20px 0;
            text-align: center;
            font-size: 2.5rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            width: 100%;
        }
        
        .mode-btn {
            padding: 15px 30px;
            font-size: 1.2rem;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            background-color: #3498db;
            color: white;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        
        .mode-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .mode-btn.active {
            background-color: #2ecc71;
        }
        
        .mode-btn.bot-hard {
            background-color: #e74c3c;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(7, 1fr);
            gap: 5px;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1/1;
            margin: 20px 0;
            background-color: #27ae60;
            border-radius: 10px;
            padding: 10px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }
        
        .cell {
            background-color: #f0f0f0;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
        }
        
        .cell:hover {
            transform: scale(1.05);
        }
        
        .cell::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 80%;
            border-radius: 50%;
            background-color: transparent;
            border: 2px dashed rgba(0,0,0,0.1);
        }
        
        .cell.red {
            background-color: #e74c3c;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
        }
        
        .cell.blue {
            background-color: #3498db;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
        }
        
        .status {
            font-size: 1.5rem;
            margin: 20px 0;
            font-weight: bold;
            color: #2c3e50;
            text-align: center;
            min-height: 40px;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .control-btn {
            padding: 10px 20px;
            font-size: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            background-color: #2c3e50;
            color: white;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        
        .control-btn:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .difficulty-selector {
            display: none;
            margin-top: 20px;
            text-align: center;
        }
        
        .difficulty-selector.active {
            display: block;
        }
        
        .difficulty-btn {
            padding: 8px 15px;
            margin: 0 5px;
            font-size: 0.9rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background-color: #bdc3c7;
            transition: all 0.2s;
        }
        
        .difficulty-btn.active {
            background-color: #e74c3c;
            color: white;
        }
        
        @media (max-width: 600px) {
            .board {
                max-width: 90vw;
            }
            
            .mode-selector {
                flex-direction: column;
                align-items: center;
            }
            
            .mode-btn {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>
    <h1>หมากฮอตมาตรฐานสากล</h1>
    
    <div class="game-container">
        <div class="mode-selector">
            <button class="mode-btn" id="pvp-btn">ผู้เล่น vs ผู้เล่น</button>
            <button class="mode-btn bot-hard" id="pve-btn">ผู้เล่น vs บอท</button>
        </div>
        
        <div class="difficulty-selector" id="difficulty-selector">
            <p>เลือกระดับความยาก:</p>
            <button class="difficulty-btn active" data-difficulty="hard">โหด</button>
            <button class="difficulty-btn" data-difficulty="medium">ปานกลาง</button>
            <button class="difficulty-btn" data-difficulty="easy">ง่าย</button>
        </div>
        
        <div class="board" id="board">
            <!-- Cells will be generated by JavaScript -->
        </div>
        
        <div class="status" id="status">เลือกโหมดการเล่น</div>
        
        <div class="controls">
            <button class="control-btn" id="restart-btn">เริ่มเกมใหม่</button>
            <button class="control-btn" id="undo-btn" disabled>ย้อนกลับ</button>
        </div>
    </div>

    <script>
        // Game constants
        const ROWS = 7;
        const COLS = 7;
        const PLAYER_RED = 'red';
        const PLAYER_BLUE = 'blue';
        
        // Game state
        let gameState = {
            board: Array(ROWS).fill().map(() => Array(COLS).fill(null)),
            currentPlayer: PLAYER_RED,
            gameMode: null, // 'pvp' or 'pve'
            gameActive: false,
            difficulty: 'hard', // 'easy', 'medium', 'hard'
            moveHistory: []
        };
        
        // DOM elements
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const pvpBtn = document.getElementById('pvp-btn');
        const pveBtn = document.getElementById('pve-btn');
        const restartBtn = document.getElementById('restart-btn');
        const undoBtn = document.getElementById('undo-btn');
        const difficultySelector = document.getElementById('difficulty-selector');
        const difficultyBtns = document.querySelectorAll('.difficulty-btn');
        
        // Initialize the game
        function initGame() {
            // Create board cells
            boardElement.innerHTML = '';
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    boardElement.appendChild(cell);
                }
            }
            
            // Reset game state
            gameState.board = Array(ROWS).fill().map(() => Array(COLS).fill(null));
            gameState.currentPlayer = PLAYER_RED;
            gameState.gameActive = false;
            gameState.moveHistory = [];
            
            updateStatus();
            updateBoard();
        }
        
        // Start a new game
        function startGame(mode) {
            gameState.gameMode = mode;
            gameState.gameActive = true;
            gameState.currentPlayer = PLAYER_RED;
            
            if (mode === 'pve') {
                difficultySelector.classList.add('active');
            } else {
                difficultySelector.classList.remove('active');
            }
            
            updateStatus();
        }
        
        // Handle cell click
        function handleCellClick(row, col) {
            if (!gameState.gameActive || gameState.board[row][col] !== null) return;
            
            // Make move
            makeMove(row, col);
            
            // If in PvE mode and game is still active, let bot make a move
            if (gameState.gameMode === 'pve' && gameState.gameActive) {
                setTimeout(() => {
                    makeBotMove();
                }, 500);
            }
        }
        
        // Make a move
        function makeMove(row, col) {
            gameState.board[row][col] = gameState.currentPlayer;
            gameState.moveHistory.push({row, col, player: gameState.currentPlayer});
            
            // Check for winner
            if (checkWin(row, col)) {
                gameState.gameActive = false;
                statusElement.textContent = `ผู้เล่น ${gameState.currentPlayer === PLAYER_RED ? 'แดง' : 'น้ำเงิน'} ชนะ!`;
                return;
            }
            
            // Check for draw
            if (checkDraw()) {
                gameState.gameActive = false;
                statusElement.textContent = 'เกมเสมอ!';
                return;
            }
            
            // Switch player
            gameState.currentPlayer = gameState.currentPlayer === PLAYER_RED ? PLAYER_BLUE : PLAYER_RED;
            
            updateStatus();
            updateBoard();
            undoBtn.disabled = gameState.moveHistory.length === 0;
        }
        
        // Bot makes a move
        function makeBotMove() {
            if (!gameState.gameActive || gameState.currentPlayer !== PLAYER_BLUE) return;
            
            let move;
            
            switch (gameState.difficulty) {
                case 'easy':
                    move = getRandomMove();
                    break;
                case 'medium':
                    move = getMediumMove();
                    break;
                case 'hard':
                    move = getBestMove();
                    break;
                default:
                    move = getBestMove();
            }
            
            if (move) {
                makeMove(move.row, move.col);
            }
        }
        
        // Get a random valid move (easy bot)
        function getRandomMove() {
            const emptyCells = [];
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (gameState.board[row][col] === null) {
                        emptyCells.push({row, col});
                    }
                }
            }
            
            if (emptyCells.length > 0) {
                return emptyCells[Math.floor(Math.random() * emptyCells.length)];
            }
            
            return null;
        }
        
        // Get a medium difficulty move (tries to win or block)
        function getMediumMove() {
            // First check if bot can win
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (gameState.board[row][col] === null) {
                        gameState.board[row][col] = PLAYER_BLUE;
                        if (checkWin(row, col)) {
                            gameState.board[row][col] = null;
                            return {row, col};
                        }
                        gameState.board[row][col] = null;
                    }
                }
            }
            
            // Then check if need to block player
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (gameState.board[row][col] === null) {
                        gameState.board[row][col] = PLAYER_RED;
                        if (checkWin(row, col)) {
                            gameState.board[row][col] = null;
                            return {row, col};
                        }
                        gameState.board[row][col] = null;
                    }
                }
            }
            
            // Otherwise make a random move
            return getRandomMove();
        }
        
        // Get the best move (hard bot - uses minimax algorithm)
        function getBestMove() {
            // First check if bot can win immediately
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (gameState.board[row][col] === null) {
                        gameState.board[row][col] = PLAYER_BLUE;
                        if (checkWin(row, col)) {
                            gameState.board[row][col] = null;
                            return {row, col};
                        }
                        gameState.board[row][col] = null;
                    }
                }
            }
            
            // Then check if need to block player from winning
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (gameState.board[row][col] === null) {
                        gameState.board[row][col] = PLAYER_RED;
                        if (checkWin(row, col)) {
                            gameState.board[row][col] = null;
                            return {row, col};
                        }
                        gameState.board[row][col] = null;
                    }
                }
            }
            
            // Try to create a fork (multiple winning opportunities)
            const forkMoves = [];
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (gameState.board[row][col] === null) {
                        gameState.board[row][col] = PLAYER_BLUE;
                        let winningMoves = 0;
                        
                        // Check how many winning moves this creates
                        for (let r = 0; r < ROWS; r++) {
                            for (let c = 0; c < COLS; c++) {
                                if (gameState.board[r][c] === null) {
                                    gameState.board[r][c] = PLAYER_BLUE;
                                    if (checkWin(r, c)) winningMoves++;
                                    gameState.board[r][c] = null;
                                }
                            }
                        }
                        
                        gameState.board[row][col] = null;
                        
                        if (winningMoves >= 2) {
                            forkMoves.push({row, col});
                        }
                    }
                }
            }
            
            if (forkMoves.length > 0) {
                return forkMoves[Math.floor(Math.random() * forkMoves.length)];
            }
            
            // Try to take the center if available
            const centerRow = Math.floor(ROWS / 2);
            const centerCol = Math.floor(COLS / 2);
            if (gameState.board[centerRow][centerCol] === null) {
                return {row: centerRow, col: centerCol};
            }
            
            // Try to take a corner
            const corners = [
                {row: 0, col: 0},
                {row: 0, col: COLS - 1},
                {row: ROWS - 1, col: 0},
                {row: ROWS - 1, col: COLS - 1}
            ];
            
            const availableCorners = corners.filter(pos => gameState.board[pos.row][pos.col] === null);
            if (availableCorners.length > 0) {
                return availableCorners[Math.floor(Math.random() * availableCorners.length)];
            }
            
            // Otherwise make a random move
            return getRandomMove();
        }
        
        // Check if the last move resulted in a win
        function checkWin(row, col) {
            const player = gameState.board[row][col];
            const directions = [
                [0, 1],  // horizontal
                [1, 0],  // vertical
                [1, 1],  // diagonal down-right
                [1, -1]  // diagonal down-left
            ];
            
            for (const [dx, dy] of directions) {
                let count = 1;
                
                // Check in positive direction
                for (let i = 1; i < 5; i++) {
                    const newRow = row + i * dx;
                    const newCol = col + i * dy;
                    
                    if (
                        newRow < 0 || newRow >= ROWS ||
                        newCol < 0 || newCol >= COLS ||
                        gameState.board[newRow][newCol] !== player
                    ) {
                        break;
                    }
                    
                    count++;
                }
                
                // Check in negative direction
                for (let i = 1; i < 5; i++) {
                    const newRow = row - i * dx;
                    const newCol = col - i * dy;
                    
                    if (
                        newRow < 0 || newRow >= ROWS ||
                        newCol < 0 || newCol >= COLS ||
                        gameState.board[newRow][newCol] !== player
                    ) {
                        break;
                    }
                    
                    count++;
                }
                
                if (count >= 5) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if the game is a draw
        function checkDraw() {
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (gameState.board[row][col] === null) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        // Undo the last move
        function undoMove() {
            if (gameState.moveHistory.length === 0) return;
            
            const lastMove = gameState.moveHistory.pop();
            gameState.board[lastMove.row][lastMove.col] = null;
            gameState.currentPlayer = lastMove.player;
            gameState.gameActive = true;
            
            updateStatus();
            updateBoard();
            undoBtn.disabled = gameState.moveHistory.length === 0;
        }
        
        // Update the board display
        function updateBoard() {
            const cells = document.querySelectorAll('.cell');
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const index = row * COLS + col;
                    const cell = cells[index];
                    
                    cell.classList.remove('red', 'blue');
                    if (gameState.board[row][col]) {
                        cell.classList.add(gameState.board[row][col]);
                    }
                }
            }
        }
        
        // Update the status display
        function updateStatus() {
            if (!gameState.gameActive) {
                if (gameState.gameMode) {
                    statusElement.textContent = 'กด "เริ่มเกมใหม่" เพื่อเล่นอีกครั้ง';
                } else {
                    statusElement.textContent = 'เลือกโหมดการเล่น';
                }
                return;
            }
            
            if (gameState.gameMode === 'pvp') {
                statusElement.textContent = `ตาผู้เล่น ${gameState.currentPlayer === PLAYER_RED ? 'แดง' : 'น้ำเงิน'}`;
            } else {
                statusElement.textContent = gameState.currentPlayer === PLAYER_RED 
                    ? 'ตาของคุณ (สีแดง)' 
                    : 'บอทกำลังคิด...';
            }
        }
        
        // Event listeners
        pvpBtn.addEventListener('click', () => {
            pvpBtn.classList.add('active');
            pveBtn.classList.remove('active');
            initGame();
            startGame('pvp');
        });
        
        pveBtn.addEventListener('click', () => {
            pveBtn.classList.add('active');
            pvpBtn.classList.remove('active');
            initGame();
            startGame('pve');
        });
        
        restartBtn.addEventListener('click', () => {
            if (gameState.gameMode) {
                initGame();
                startGame(gameState.gameMode);
            }
        });
        
        undoBtn.addEventListener('click', undoMove);
        
        difficultyBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                difficultyBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameState.difficulty = btn.dataset.difficulty;
            });
        });
        
        // Initialize the game on load
        initGame();
    </script>
</body>
</html>